# -*- coding: utf-8 -*-
"""dashboard-de-an-lise-de-fluxo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/harleyh3x-afk/c5d73eb184bd396345c2f91637fb5e68/dashboard-de-an-lise-de-fluxo.ipynb
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from io import StringIO
import time

# --- Configura√ß√£o da P√°gina ---
st.set_page_config(
    page_title="Dashboard de An√°lise de Fluxo",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Fun√ß√µes de C√°lculo (O motor do aplicativo) ---

def processar_dados(texto_dados):
    """L√™ o texto colado, limpa e prepara os dados para an√°lise."""
    if not texto_dados:
        return pd.DataFrame()
    try:
        # Usar StringIO para ler o texto como se fosse um arquivo
        # O separador '\s\s+' tenta lidar com m√∫ltiplos espa√ßos ou tabula√ß√µes
        dados = pd.read_csv(StringIO(texto_dados), sep='\s\s+', engine='python', header=0)

        # Renomear colunas para garantir consist√™ncia
        dados.columns = ['Data', 'Compradora', 'Valor', 'Quantidade', 'Vendedora', 'Agressor']

        # Limpeza e convers√£o de tipos
        dados['Data'] = pd.to_datetime(dados['Data'], format='%d/%m/%Y%H:%M:%S', errors='coerce')
        dados['Valor'] = pd.to_numeric(dados['Valor'].str.replace('.', '').str.replace(',', '.'), errors='coerce')
        dados['Quantidade'] = pd.to_numeric(dados['Quantidade'], errors='coerce')

        # Remover linhas com dados inv√°lidos que n√£o puderam ser convertidos
        dados.dropna(inplace=True)

        return dados
    except Exception as e:
        st.error(f"Erro ao processar os dados: {e}. Verifique o formato do texto colado.")
        return pd.DataFrame()

def calcular_metricas(df):
    """Calcula todas as m√©tricas necess√°rias para os gr√°ficos."""
    # L√≥gica de Agress√£o e Passividade
    df['Agg_Compradora'] = df.apply(lambda row: row['Quantidade'] if row['Agressor'] == 'Comprador' else 0, axis=1)
    df['Agg_Vendedora'] = df.apply(lambda row: row['Quantidade'] if row['Agressor'] == 'Vendedor' else 0, axis=1)
    df['Pass_Compradora'] = df.apply(lambda row: row['Quantidade'] if row['Agressor'] == 'Vendedor' else 0, axis=1)
    df['Pass_Vendedora'] = df.apply(lambda row: row['Quantidade'] if row['Agressor'] == 'Comprador' else 0, axis=1)

    return df

# --- Estado da Sess√£o (Para guardar informa√ß√µes entre intera√ß√µes) ---
if 'dados_processados' not in st.session_state:
    st.session_state.dados_processados = pd.DataFrame()
if 'dados_carregados' not in st.session_state:
    st.session_state.dados_carregados = False
if 'playback_index' not in st.session_state:
    st.session_state.playback_index = 0
if 'is_playing' not in st.session_state:
    st.session_state.is_playing = False

# --- Interface do Usu√°rio (O que voc√™ v√™ na tela) ---

st.title("üìä Dashboard de An√°lise de Fluxo de Ordens")
st.markdown("---")

# --- Abas de Navega√ß√£o ---
tab_dados, tab_evolucao, tab_raiox, tab_regiao, tab_micro = st.tabs([
    "1. Dados",
    "2. Evolu√ß√£o no Tempo",
    "3. Raio-X do Fluxo",
    "4. Atua√ß√£o por Regi√£o",
    "5. Microestrutura"
])

# --- Aba 1: Dados ---
with tab_dados:
    st.header("Carregar Dados do Times and Trades")
    texto_dados_input = st.text_area(
        "Cole aqui os dados do Times and Trades para carregar na base de dados",
        height=300,
        key="dados_input"
    )

    if st.button("Processar e Carregar"):
        with st.spinner("Processando..."):
            dados_brutos = processar_dados(texto_dados_input)
            if not dados_brutos.empty:
                st.session_state.dados_processados = calcular_metricas(dados_brutos)
                st.session_state.dados_carregados = True
                st.session_state.playback_index = len(st.session_state.dados_processados) -1
                st.success(f"{len(dados_brutos)} trades carregados com sucesso!")
            else:
                st.session_state.dados_carregados = False
                st.warning("Nenhum dado v√°lido foi carregado.")

# --- Barra Lateral de Controle ---
with st.sidebar:
    st.header("Filtros Globais")

    if st.session_state.dados_carregados:
        df = st.session_state.dados_processados

        # Sele√ß√£o de Players
        all_players = sorted(pd.concat([df['Compradora'], df['Vendedora']]).unique())
        player_volumes = df.groupby('Compradora')['Quantidade'].sum().add(df.groupby('Vendedora')['Quantidade'].sum(), fill_value=0).sort_values(ascending=False)
        top_5_players = player_volumes.head(5).index.tolist()

        st.subheader("Sele√ß√£o de Players")
        selected_players = st.multiselect(
            "Selecione os players para an√°lise:",
            options=all_players,
            default=top_5_players
        )

        # Agrupamento de Tempo
        st.subheader("Agrupamento de Tempo")
        time_frame = st.selectbox(
            "Compilar gr√°ficos por:",
            options=['1 segundo', '5 segundos', '15 segundos', '30 segundos', '1 minuto', '5 minutos', '15 minutos'],
            index=4 # Padr√£o '1 minuto'
        )
        time_map = {
            '1 segundo': '1S', '5 segundos': '5S', '15 segundos': '15S',
            '30 segundos': '30S', '1 minuto': '1T', '5 minutos': '5T', '15 minutos': '15T'
        }
        resample_rule = time_map[time_frame]

        # Controle de Timelapse
        st.subheader("Controle de Timelapse")

        # Agrupar dados pelo time frame escolhido para o slider
        time_steps = df.set_index('Data').resample(resample_rule).size().index

        if len(time_steps) > 1:
            st.session_state.playback_index = st.slider(
                "Navegue pelo tempo:",
                min_value=0,
                max_value=len(time_steps) - 1,
                value=st.session_state.playback_index,
                format="%d"
            )
            current_time_step = time_steps[st.session_state.playback_index]
            st.info(f"Visualizando dados at√©: {current_time_step.strftime('%H:%M:%S')}")
        else:
            current_time_step = df['Data'].max() if not df.empty else pd.Timestamp.now()


        # Bot√µes de Playback
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("‚è™ Voltar"):
                st.session_state.playback_index = max(0, st.session_state.playback_index - 1)
        with col2:
            if st.button("Play/Pause ‚ñ∂Ô∏è‚è∏Ô∏è"):
                st.session_state.is_playing = not st.session_state.is_playing
        with col3:
            if st.button("Avan√ßar ‚è©"):
                st.session_state.playback_index = min(len(time_steps) - 1, st.session_state.playback_index + 1)

        speed = st.selectbox("Velocidade:", [1, 2, 3, 4, 5], index=0)
        repeat = st.checkbox("Repetir")

    else:
        st.info("Carregue os dados na aba '1. Dados' para habilitar os filtros.")


# --- L√≥gica de atualiza√ß√£o dos gr√°ficos com base no playback ---
if st.session_state.dados_carregados:
    df_filtrado_tempo = df[df['Data'] <= current_time_step]

    # --- Aba 2: Evolu√ß√£o no Tempo ---
    with tab_evolucao:
        st.header("Evolu√ß√£o dos Players no Tempo")

        tipo_saldo = st.radio(
            "Selecione o tipo de an√°lise:",
            options=['Saldo Resultante', 'Agress√£o L√≠quida', 'Passivo L√≠quido', 'Apenas Compras', 'Apenas Vendas'],
            horizontal=True
        )

        if not df_filtrado_tempo.empty and selected_players:
            # L√≥gica para calcular o saldo de cada player
            data_plot = []
            for player in selected_players:
                # Compras e Vendas do player
                compras = df_filtrado_tempo[df_filtrado_tempo['Compradora'] == player]['Quantidade'].sum()
                vendas = df_filtrado_tempo[df_filtrado_tempo['Vendedora'] == player]['Quantidade'].sum()

                # Agress√µes
                agg_compra = df_filtrado_tempo[(df_filtrado_tempo['Compradora'] == player) & (df_filtrado_tempo['Agressor'] == 'Comprador')]['Quantidade'].sum()
                agg_venda = df_filtrado_tempo[(df_filtrado_tempo['Vendedora'] == player) & (df_filtrado_tempo['Agressor'] == 'Vendedor')]['Quantidade'].sum()

                # Passivos
                pass_compra = df_filtrado_tempo[(df_filtrado_tempo['Compradora'] == player) & (df_filtrado_tempo['Agressor'] == 'Vendedor')]['Quantidade'].sum()
                pass_venda = df_filtrado_tempo[(df_filtrado_tempo['Vendedora'] == player) & (df_filtrado_tempo['Agressor'] == 'Comprador')]['Quantidade'].sum()

                saldo = 0
                if tipo_saldo == 'Saldo Resultante':
                    saldo = compras - vendas
                elif tipo_saldo == 'Agress√£o L√≠quida':
                    saldo = agg_compra - agg_venda
                elif tipo_saldo == 'Passivo L√≠quido':
                    saldo = pass_compra - pass_venda
                elif tipo_saldo == 'Apenas Compras':
                    saldo = compras
                elif tipo_saldo == 'Apenas Vendas':
                    saldo = vendas

                data_plot.append({'Player': player, 'Saldo': saldo})

            df_plot = pd.DataFrame(data_plot)

            col_graf, col_tab = st.columns([3, 1])
            with col_graf:
                fig = px.bar(df_plot, x='Player', y='Saldo', color='Player', title=f"Evolu√ß√£o at√© {current_time_step.strftime('%H:%M:%S')}")
                st.plotly_chart(fig, use_container_width=True)
            with col_tab:
                st.dataframe(df_plot.set_index('Player'))
        else:
            st.info("Selecione players para visualizar a evolu√ß√£o.")


    # --- Aba 3: Raio-X do Fluxo ---
    with tab_raiox:
        st.header("Raio-X do Fluxo: Delta e Volume")
        if not df_filtrado_tempo.empty:
            df_resampled = df_filtrado_tempo.set_index('Data').resample(resample_rule).agg({
                'Agg_Compradora': 'sum',
                'Agg_Vendedora': 'sum',
                'Quantidade': 'sum'
            }).reset_index()

            df_resampled['Delta'] = df_resampled['Agg_Compradora'] - df_resampled['Agg_Vendedora']

            fig = go.Figure()
            # Gr√°fico de Delta
            fig.add_trace(go.Bar(
                x=df_resampled['Data'],
                y=df_resampled['Delta'],
                name='Saldo Delta',
                marker_color=['green' if d > 0 else 'red' for d in df_resampled['Delta']],
                yaxis='y1'
            ))
            # Gr√°fico de Volume
            fig.add_trace(go.Bar(
                x=df_resampled['Data'],
                y=df_resampled['Quantidade'],
                name='Volume Total',
                marker_color='lightblue',
                yaxis='y2'
            ))

            fig.update_layout(
                title='Saldo Delta vs. Volume Total de Agress√£o',
                xaxis_title='Tempo',
                yaxis_title='Saldo Delta',
                yaxis2=dict(
                    title='Volume Total',
                    overlaying='y',
                    side='right'
                ),
                barmode='relative',
                legend=dict(x=0, y=1.1, orientation='h')
            )
            st.plotly_chart(fig, use_container_width=True)

    # --- Aba 4: Atua√ß√£o por Regi√£o ---
    with tab_regiao:
        st.header("An√°lise de Atua√ß√£o por Regi√£o")
        player_selecionado = st.selectbox(
            "Selecione um player para an√°lise detalhada:",
            options=all_players if 'all_players' in locals() else []
        )
        if player_selecionado and not df_filtrado_tempo.empty:
            df_player = df_filtrado_tempo[
                (df_filtrado_tempo['Compradora'] == player_selecionado) |
                (df_filtrado_tempo['Vendedora'] == player_selecionado)
            ]

            vap_data = df_player.groupby('Valor').agg(
                Agg_Volume=('Agg_Compradora', lambda x: x[df_player['Compradora'] == player_selecionado].sum() + x[df_player['Vendedora'] == player_selecionado].sum()),
                Pass_Volume=('Pass_Compradora', lambda x: x[df_player['Compradora'] == player_selecionado].sum() + x[df_player['Vendedora'] == player_selecionado].sum())
            ).reset_index()

            fig = go.Figure()
            fig.add_trace(go.Bar(
                y=vap_data['Valor'],
                x=vap_data['Agg_Volume'],
                name='Volume de Agress√£o',
                orientation='h',
                marker_color='blue'
            ))
            fig.add_trace(go.Bar(
                y=vap_data['Valor'],
                x=vap_data['Pass_Volume'],
                name='Volume de Absor√ß√£o',
                orientation='h',
                marker_color='orange'
            ))
            fig.update_layout(
                title=f'VAP de Agress√£o vs. Absor√ß√£o para {player_selecionado}',
                barmode='stack',
                yaxis_title='Pre√ßo (Valor)',
                xaxis_title='Volume',
                yaxis=dict(autorange="reversed") # Pre√ßos mais altos em cima
            )
            st.plotly_chart(fig, use_container_width=True)

    # --- Aba 5: Microestrutura ---
    with tab_micro:
        st.header("Microestrutura: Esfor√ßo vs. Resultado")
        if not df_filtrado_tempo.empty:
            df_filtrado_tempo['Delta'] = df_filtrado_tempo['Agg_Compradora'] - df_filtrado_tempo['Agg_Vendedora']
            esforco_resultado = df_filtrado_tempo.groupby('Valor')['Delta'].sum().reset_index()

            fig = px.bar(
                esforco_resultado,
                y='Valor',
                x='Delta',
                orientation='h',
                title='Esfor√ßo (Delta) vs. Resultado (Pre√ßo)',
                labels={'Delta': 'Saldo Delta Acumulado', 'Valor': 'N√≠vel de Pre√ßo'}
            )
            fig.update_layout(yaxis=dict(autorange="reversed"))
            st.plotly_chart(fig, use_container_width=True)


# --- L√≥gica de Playback Autom√°tico ---
if st.session_state.is_playing:
    max_index = len(time_steps) - 1 if 'time_steps' in locals() and len(time_steps) > 0 else 0
    if st.session_state.playback_index >= max_index:
        if repeat:
            st.session_state.playback_index = 0
        else:
            st.session_state.is_playing = False
    else:
        st.session_state.playback_index += 1

    time.sleep(1 / speed)
    st.experimental_rerun()



# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit

"""# Task
Forne√ßa um passo a passo para um iniciante em Python sobre como executar um dashboard criado com Streamlit, incluindo como salvar o c√≥digo, usar o GitHub para versionamento e implanta√ß√£o no Streamlit Cloud.

## Salvar o c√≥digo python

### Subtask:
Copie o c√≥digo do seu dashboard e salve-o em um arquivo com extens√£o `.py` (por exemplo, `dashboard_fluxo.py`) no seu computador.

## Criar uma conta no github

### Subtask:
Se voc√™ ainda n√£o tem uma conta, crie uma no GitHub. O GitHub √© onde voc√™ vai armazenar o c√≥digo online.

## Criar um novo reposit√≥rio no github

### Subtask:
No GitHub, crie um novo reposit√≥rio (como se fosse uma pasta para o seu projeto). D√™ um nome a ele (por exemplo, `dashboard-fluxo-streamlit`).

## Fazer upload do arquivo python para o github

### Subtask:
Dentro do seu novo reposit√≥rio no GitHub, fa√ßa o upload do arquivo `dashboard_fluxo.py` que voc√™ salvou no passo 1.

## Criar uma conta no streamlit cloud

### Subtask:
V√° para o Streamlit Cloud e crie uma conta. Voc√™ pode usar sua conta do GitHub para fazer login, o que facilita a conex√£o.

## Implantar o aplicativo no streamlit cloud

### Subtask:
No Streamlit Cloud, voc√™ ver√° a op√ß√£o para "New app" ou "Deploy an app". Selecione seu reposit√≥rio do GitHub, o branch (geralmente `main` ou `master`) e o nome do arquivo Python principal (`dashboard_fluxo.py`).

## Aguardar a implanta√ß√£o

### Subtask:
O Streamlit Cloud vai ler seu c√≥digo, instalar as bibliotecas necess√°rias e construir o aplicativo. Isso pode levar alguns minutos.

## Acessar o dashboard

### Subtask:
Assim que a implanta√ß√£o terminar, o Streamlit Cloud fornecer√° um link p√∫blico para o seu dashboard. Voc√™ poder√° acessar o dashboard usando esse link em qualquer navegador.

## Summary:

### Data Analysis Key Findings

*   The process outlines the steps for a beginner to deploy a Streamlit dashboard, starting from saving the Python code locally.
*   It includes instructions for using GitHub for version control by creating an account, a new repository, and uploading the Python file.
*   The guide details creating an account on Streamlit Cloud, preferably using GitHub for easier connection.
*   A crucial step is deploying the application on Streamlit Cloud by selecting the GitHub repository, branch, and the main Python file.
*   The process highlights the waiting period required for Streamlit Cloud to build and deploy the application, including installing necessary libraries.
*   Finally, it explains how to access the deployed dashboard using the public link provided by Streamlit Cloud.

### Insights or Next Steps

*   The user now has a clear step-by-step guide to deploy their Streamlit dashboard from development to a publicly accessible link using GitHub and Streamlit Cloud.
*   A useful next step would be to guide the user on how to update their deployed dashboard by making changes to the code, pushing those changes to GitHub, and triggering a redeployment on Streamlit Cloud.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit

"""# Task
Explain how to install Python libraries.

## Save the code

### Subtask:
Save the Streamlit application code to a Python file (e.g., `dashboard_fluxo.py`).

## Open a terminal

### Subtask:
Open a terminal or command prompt on your computer.

## Navigate to the file directory

### Subtask:
Use the `cd` command to go to the directory where you saved the Python file.

## Run the streamlit app

### Subtask:
Run the Streamlit app.

## Summary:

### Data Analysis Key Findings
*   The primary goal was to guide a user on how to run a Streamlit application, which involves a series of steps to be performed in the user's local environment.
*   The process began with instructions to save the provided Python code into a file named `dashboard_fluxo.py`.
*   Subsequent steps involved user actions outside of the direct control of the system, such as opening a terminal and navigating to the correct file directory using the `cd` command.
*   The final step was to provide the user with the command `streamlit run dashboard_fluxo.py` to execute in their terminal, which would start the Streamlit application server.

### Insights or Next Steps
*   Since the process relies on user actions in their local environment, it's beneficial to provide clear, platform-specific instructions (e.g., for Windows, macOS, and Linux) to minimize user confusion.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install plotly

